# 协程的简单理解及yield关键字实现协程

## 1.什么是协程（Coroutine）

**协程是python个中另外一种实现多任务的方式**，只不过比线程更小占用更小执行单元（理解为需要的资源）。 为啥说它是一个执行单元，因为它自带CPU上下文。这样只要在合适的时机， 我们可以把一个协程 切换到另一个协程。 只要这个过程中保存或恢复 CPU上下文那么程序还是可以运行的。

**通俗的理解：在一个线程中的某个函数，可以在任何地方保存当前函数的一些临时变量等信息，然后切换到另外一个函数中执行，注意不是通过调用函数的方式做到的，并且切换的次数以及什么时候再切换到原来的函数都由开发者自己确定**

## 2.协程（Coroutine的直观理解）

 yield个人认为其实是为了实现协程而出现的。所以如果要解释清楚什么是yield，那么也就必须要先搞懂什么是协程。首先明确一点：**协程是针对单个CPU的，也就是说，讲协程讲的就是单线程**。我们可以通过协程实现类似并发的任务，并且如果只是在一个CPU上的话，使用协程带来的效率一般都会比使用线程来的高。这是为啥呢？这就要看协程的原理了。等IO、等信号啥的，这些时间CPU给了你你也没用。

### 2.1为什么yield可以实现协程

yield具有一个延迟加载的特性，所谓的延迟加载就是当运行执行到yield关键词时，会保存当前程序运行状态，自动跳出当前函数遇到下次yield关键词会返回上一个yield关键词位置继续执行之后的代码，这就有了一个上下文概念。

在Python中，协程通过yield实现。因为当一个函数中有yield存在的时候，这个函数是生成器，那么当你调用这个函数的时候，你在函数体中写的代码并没有被执行，而是只返回了一个生成器对象，这个需要特别注意。然后，你的代码将会在每次使用这个生成器的时候被执行。①返回一个值、②接收调用者的参数中断等待的功能”，才使得yield可以实现协程。

### 2.2 yield实现协程的例子

```python
def consumer():
    r = ''
    while True:
        n = yield r  # 执行的中断点
        if not n:
            return
        print('[消费者] 正在消费:{0}'.format(n))
        r = '200 人民币'


def produce(c):
    c.send(None)  # 启动消费者（生成器）——实际上是函数调用，只不过生成器不是直接象函数那般调用的
    n = 0
    while n < 5:
        n = n + 1
        print('[生产者] 正在生产:{0}'.format(n))
        r = c.send(n)  # 给消费者传入值——实际上也是函数调用
        print('[生产者] 消费者返回:{0}'.format(r))
        print('-------------------------------------------------')
    c.close()


c = consumer()  # 构造一个生成器
produce(c)
```

运行结果：

```python
[生产者] 正在生产:1
[消费者] 正在消费:1
[生产者] 消费者返回:200 人民币
-------------------------------------------------
[生产者] 正在生产:2
[消费者] 正在消费:2
[生产者] 消费者返回:200 人民币
-------------------------------------------------
[生产者] 正在生产:3
[消费者] 正在消费:3
[生产者] 消费者返回:200 人民币
-------------------------------------------------
[生产者] 正在生产:4
[消费者] 正在消费:4
[生产者] 消费者返回:200 人民币
-------------------------------------------------
[生产者] 正在生产:5
[消费者] 正在消费:5
[生产者] 消费者返回:200 人民币
-------------------------------------------------
```

解释分析：这相当于是调用consumer(),但是如果consumer是一个普通函数而不是生成器，就要等到consumer执行完了，主动权才会重新回到producer手里。但就是因为consumer是生成器，所以第一次遇到yield暂停；接着执行produce()中接下来的代码，从运行结果看，确实打印出了[生产者] 正在生产 1 ，当程序运行至c.send(n)时，再次调用生成器并且通过yield传递了参数(n = 1)，这个时候，进入consumer()函数先前在yield停下的地方，继续向后执行，所以打印出[消费者] 正在消费 1。第二步：[消费者] 正在消费 1 这句话被打印出来之后，接下consumer()函数中此时 r 被赋值为’200 人民币’,接着consumer()函数里面的第一次循环结束，进入第二次循环，又遇到yield， 所以consumer()函数又暂停并且返回变量 r 的值，consumer()函数暂停，此时程序又进入produce(c)函数中接着执行。第三步：由于先前produce(c)函数接着第一次循环中c.send(n)处相当于是调用消费者consumer(),跳入到了consumer()里面去执行，现在consumer暂停，producer重新我有主动权，故而继续往下执行打印出[生产者] 消费者返回: 200 人民币，然后producer的第一次循环结束，并进行第二次循环，打印出[生产者] 正在生产 1，然后，又调用c.send(n) 又调用消费者consumer，将控制权交给consumer，如此循环回到第一步！