# yield from 详解

## 1.yield from的简单实现

从前面的系列文章中，我们了解到，yield是每次“惰性返回”一个值，其实从名字中就能看出，yield from 是yield的升级改进版本，如果将yield理解成“返回”，那么yield from就是“**从什么（生成器）里面返回”**，这就构成了yield from的一般语法

```python
yield from generator
```

 yield from iterable 本质上等于 

```python
for item in iterable: 
    yield item
```

demo:

```python
def generator2():
    yield 'a'
    yield 'b'
    yield 'c'
    yield from [11, 22, 33, 44]
    yield from (12, 23, 34)
    yield from range(3)


for i in generator2():
    print(i, end=' , ')
```

总结：生成器 、元组、 列表、range（）函数产生的序列等可迭代对象”返回另外一个生成器。而yield只是返回一个元素。从这个层面来说，有下面的等价关系：yield from iterable本质上等于 for item in iterable: yield item 。

## 2.yield from的高级应用

### 2.1针对yiled无法获取生成器return的返回值

我们都知道，在使用yield生成器的时候，如果使用for语句去迭代生成器，则不会显式的触发StopIteration异常，而是自动捕获StopIteration异常，所以如果遇到return，只是会终止迭代，而不会触发异常，故而也就没办法获取return的值。如下：

```python
def my_generator():
    for i in range(5):
        if i == 2:
            return '我被迫中断了'
        else:
            yield i


def main(generator):
    try:
        for i in generator:  # 不会显式触发异常，故而无法获取到return的值
            print(i)
    except StopIteration as exc:
        print(exc.value)


g = my_generator()  # 调用
main(g)
```

运行结果：

```python
0
1
```

从上面的例子可以看出，for迭代语句不会显式触发异常，故而无法获取到return的值，迭代到2的时候遇到return语句，隐式的触发了StopIteration异常，就终止迭代了，但是在程序中不会显示出来。

```python
def my_generator():
    for i in range(5):
        if i == 2:
            return '我被迫中断了'
        else:
            yield i


def main(generator):
    try:
        print(next(generator))  # 每次迭代一个值，则会显式出发StopIteration
        print(next(generator))
        print(next(generator))
        print(next(generator))
        print(next(generator))
    except StopIteration as exc:
        print(exc.value)  # 获取返回的值


g = my_generator()
main(g)
```

运行结果：

```python
0
1
我被迫中断了
```

现在我们使用yield from来完成上面的同样的功能：

```python
def my_generator():
    for i in range(5):
        if i == 2:
            return '我被迫中断了'
        else:
            yield i


def wrap_my_generator(generator):  # 定义一个包装“生成器”的生成器，它的本质还是生成器
    result = yield from generator  # 自动触发StopIteration异常，并且将return的返回值赋值给yield from表达式的结果，即result
    print(result)


def main(generator):
    for j in generator:
        print(j)


g = my_generator()
wrap_g = wrap_my_generator(g)
main(wrap_g)  # 调用
```

运行结果：

```python
0
1
我被迫中断了
```

从上面的比较可以看出，yield from具有以下几个特点：

（1）上面的my_generator是原始的生成器，main是调用方，使用yield的时候，只涉及到这两个函数，即“调用方”与“生成器（协程函数）”是直接进行交互的，不涉及其他方法，即**“调用方——>生成器函数(协程函数)”**；

（2）在使用yield from的时候，多了一个对原始my_generator的包装函数，然后调用方是通过这个包装函数（后面会讲到它专有的名词）来与生成器进行交互的，即**“调用方——>生成器包装函数——>生成器函数(协程函数)”；**

（3）yield from iteration结构会在内部自动捕获 iteration生成器的StopIteration 异常。这种处理方式与 for 循环处理 StopIteration 异常的方式一样。而且对 yield from 结构来说，解释器不仅会捕获 StopIteration 异常，还会把return返回的值或者是StopIteration的value 属性的值变成 yield from 表达式的值，即上面的result。

### 2.2 yield from所实现的数据传输通道

前面总结的几个特点里面已经介绍了yield和yield from的数据交互方式，yield涉及到“调用方与生成器两者”的交互，生成器通过next()的调用将值返回给调用者，而调用者通过send()方法向生成器发送数据；

但是yield还有一个第三者函数，下面将先从相关的概念说起。

在PEP 380 使用了一些yield from使用的专门术语：

**委派生成器：**包含 yield from  iterable 表达式的生成器函数；即上面的wrap_my_generator生成器函数

**子生成器：**从 yield from 表达式中 iterable 部分获取的生成器；即上面的my_generator生成器函数

**调用方：**调用委派生成器的客户端代码；即上面的main生成器函数

下图是这三者之间的交互关系：

![img](..\..\src\10.再议协程\yield数据管道传输.png)

委派生成器在 yield from 表达式处暂停时，调用方可以直接把数据发给子生成器，子生成器再把产出的值发给调用方。子生成器返回之后，解释器会抛出StopIteration 异常，并把返回值附加到异常对象上，此时委派生成器会恢复。

**系统模型：**

假设我们有一个系统, 它的业务需求是这样：

1. 需要读取一段放在一个常量列表中的文本， 每个item表示一行文本。

2. 每读入一行，则先打印双小于号 "<<"，然后打印读入的文本行

3. 如果文本全部成功读取，则最后打印“done”表示应用正常结束

   

系统最初版本，由一个reader和app实现，转化的软件需求分别如下：

1. reader是一个generator。

　　 1）用来模拟文本读取，每次读取text中一行，并返回该行文本

​     	2）如果文本全部读完，返回‘done’

2. app是主线业务, 软件需求如下：

      1）while循环中，每次通过next读取reader一个生成的值，并在文本前加“<<"后打印

      2）如果reader产生StopIteration异常, 则打印reader的返回值

这个初版用python实现如下：

demo:

```python
# reader是一个生成器， 每次调用，它将读取列表中一个值并返回
def reader(text):
    for line in text:
        yield line
    return 'done'


# app是定义的一个简单应用，将reader读出的值打印出来
def app(text):
    try:
        r = reader(text)
        while True:
            line = next(r)
            print('<< %s' % line)
    except StopIteration as e:
        print(e.value)


# 启动app应用
app(('a', 'b', 'c', 'd'))
```

运行结果：

```python
<< a
<< b
<< c
<< d
done
```

**新需求引入:**

现在系统需求改变了，在文件开始读取和结束读取之后，需要记录日志以满足运维需求，但系统原有业务无关，是和主线业务正交的非业务需求。为了避免以后再次修改app应用，引入一个**代理proxyReader**处理这些切面类需求。

1）Reader只涉及底层文本读取，和之前一样。

2）定义前后两个方法。 运维需求省略具体实现，并且抽象成一个before和after方法，里面可以添加记录日志等运维相关的需求



**总结：**

**（1）yield from主要设计用来向子生成器委派操作任务，**但yield from可以向任意的可迭代对象委派操作；

**（2）委派生成器（group）相当于管道，**所以可以把任意数量的委派生成器连接在一起---一个委派生成器使用yield from 调用一个子生成器，而那个子生成器本身也是委派生成器，使用yield from调用另一个生成器。