# 从生成器和yield表达式说起

## 1.实现一个简单的生成器

```python
def my_generator(n):
    for i in range(n):
        yield i
```

## 2.send()方法的使用

```python
# -*- coding:utf-8 -*-
# send方法使用
def my_generator(n):
    for i in range(n):
        temp = yield i
        print(f"我是{temp}")


g = my_generator(5)

print(next(g))  # 输出0,到yield停止抛出
print("=" * 30)
# 0

print(next(g))  # 继续运行yield之后。此时temp还未被赋值所以是None,继续下次循环所以输出1
# 我是None
# 1

print("*" * 30)
g.send(100)  # 继续yield之后的操作此时为，本来输出的2.但是传入了新值100，所以yield表达式为100也就是说temp为100
# 我是100

print("-" * 30)
print(next(g))  # 继续运行yield之后。此时temp还未被赋值所以是None，2已经被替换了所以输出3
# 我是None
# 3

print("+" * 30)
print(next(g))  # 继续运行yield之后。此时temp还未被赋值所以是None，继续输出为4
# 我是None
# 4
```

从上面可以看出yield语句与普通函数的return语句的区别在哪里了，主要集中在以下几点

（1）return 不能写成“temp=return xxxx”的形式，会提示语法错误，但是yield可以写成“temp=yield xxxx”的形式；

（2）普通函数return后面的语句都是不会再执行的，但是yield语句后面的依然会执行，但是需要注意的是，由于“**延迟加载**”特性，yield后面的代码并不是在第一次迭代的时候执行的，而是第二次迭代的时候才执行第一次yield后面没有执行的代码。也正是这个特性，构成了yield为什么是实现协程的最简单实现。

（3）使用send()方法传进去的值，实际上就是yield表达式返回的值，这就是为什么前面每次输出print(temp)都打印出None，因为没有send值，所以temp为None，但是send（100）之后却打印100，因为此时temp就是100了。

Eg:

```python
# -*- coding:utf-8 -*-
# send方法使用
def my_generator(n):
    for i in range(n):
        temp = yield  # 不返回值这时候无法迭代值，每次都是None
        print(f"我是{temp}")


g = my_generator(5)
print(next(g))  # 输出None,到yield停止抛出
# None

print("=" * 30)
print(next(g))  # 继续运行yield之后。此时temp还未被赋值所以是None,继续下次循环所以输出None
# 我是None
# None

print("*" * 30)
g.send(100)  # 继续yield之后的操作此时为，本来输出的2.但是传入了新值100，所以yield表达式为100也就是说temp为100
# 我是100

print("-" * 30)
print(next(g))
# 我是None
# None

print("+" * 30)
print(next(g))
# 我是None
# None
```



